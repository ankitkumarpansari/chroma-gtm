name: Claude GTM Assistant

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

jobs:
  claude-assistant:
    if: >-
      contains(github.event.issue.body, '@claude') ||
      contains(github.event.issue.title, '@claude') ||
      contains(github.event.comment.body, '@claude')
    
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Load conversation history
        id: history
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get all comments on this issue for conversation context
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 20
            });
            
            // Build conversation history
            let history = [];
            
            // Add original issue
            const issue = context.payload.issue;
            history.push(`USER: ${issue.title}\n${issue.body || ''}`);
            
            // Add all comments
            for (const comment of comments.data) {
              if (comment.user.login === 'github-actions[bot]') {
                history.push(`ASSISTANT: ${comment.body}`);
              } else if (comment.body && comment.body.toLowerCase().includes('@claude')) {
                history.push(`USER: ${comment.body}`);
              }
            }
            
            // Save to file
            fs.writeFileSync('/tmp/conversation.txt', history.join('\n\n---\n\n'));
            
            console.log(`Loaded ${history.length} messages in conversation`);
            return history.length;
      
      - name: Parse query and detect intent
        id: parse
        env:
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # Get the LATEST query (current request)
          if [ "$EVENT_NAME" == "issue_comment" ]; then
            QUERY="$COMMENT_BODY"
            IS_FOLLOWUP="true"
          else
            QUERY="$ISSUE_TITLE $ISSUE_BODY"
            IS_FOLLOWUP="false"
          fi
          
          # Remove @claude from query
          QUERY=$(echo "$QUERY" | sed 's/@[Cc]laude//g' | xargs)
          echo "$QUERY" > /tmp/query.txt
          
          echo "is_followup=$IS_FOLLOWUP" >> $GITHUB_OUTPUT
          
          # Detect intent
          QUERY_LOWER=$(echo "$QUERY" | tr '[:upper:]' '[:lower:]')
          
          if [ "$IS_FOLLOWUP" == "true" ]; then
            MODE="followup"
            echo "target=" >> $GITHUB_OUTPUT
          elif echo "$QUERY_LOWER" | grep -qE '^email' && echo "$QUERY" | grep -qE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'; then
            MODE="email"
            EMAIL=$(echo "$QUERY" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' | head -1)
            echo "target=$EMAIL" >> $GITHUB_OUTPUT
          elif echo "$QUERY_LOWER" | grep -qE '^research'; then
            MODE="research"
            TARGET=$(echo "$QUERY" | sed -E 's/^[Rr]esearch[[:space:]]*//')
            echo "target=$TARGET" >> $GITHUB_OUTPUT
          elif echo "$QUERY_LOWER" | grep -qE '^linkedin'; then
            MODE="linkedin"
            TARGET=$(echo "$QUERY" | sed -E 's/^[Ll]inkedin[[:space:]]*//')
            echo "target=$TARGET" >> $GITHUB_OUTPUT
          elif echo "$QUERY_LOWER" | grep -qE '^competitor'; then
            MODE="competitor"
            TARGET=$(echo "$QUERY" | sed -E 's/^[Cc]ompetitor[s]?[[:space:]]*//')
            echo "target=$TARGET" >> $GITHUB_OUTPUT
          else
            MODE="general"
            echo "target=" >> $GITHUB_OUTPUT
          fi
          
          echo "mode=$MODE" >> $GITHUB_OUTPUT
          echo "Detected mode: $MODE"
      
      - name: Load context
        run: |
          # Core context - using || true to prevent failures
          touch /tmp/context.txt
          cat CLAUDE.md >> /tmp/context.txt 2>/dev/null || true
          cat context/GTM_CONTEXT.md >> /tmp/context.txt 2>/dev/null || true
          cat context/MEETING_INDEX.md >> /tmp/context.txt 2>/dev/null || true
          cat CHROMA_COMPETITORS.md >> /tmp/context.txt 2>/dev/null || true
          
          # Truncate to safe size
          head -c 50000 /tmp/context.txt > /tmp/context_final.txt
          echo "Context loaded: $(wc -c < /tmp/context_final.txt) bytes"
      
      - name: Build prompt
        id: prompt
        env:
          MODE: ${{ steps.parse.outputs.mode }}
          TARGET: ${{ steps.parse.outputs.target }}
        run: |
          QUERY=$(cat /tmp/query.txt)
          CONVERSATION=$(cat /tmp/conversation.txt 2>/dev/null || echo "No previous conversation")
          
          # Create prompt based on mode
          if [ "$MODE" == "followup" ]; then
            cat > /tmp/prompt.txt << 'EOF'
          CONVERSATION HISTORY:
          EOF
            cat /tmp/conversation.txt >> /tmp/prompt.txt
            echo "" >> /tmp/prompt.txt
            echo "---" >> /tmp/prompt.txt
            echo "NEW REQUEST: $QUERY" >> /tmp/prompt.txt
            echo "" >> /tmp/prompt.txt
            echo "Respond to the user's request. If modifying something, provide the full updated version." >> /tmp/prompt.txt
          
          elif [ "$MODE" == "email" ]; then
            NAME=$(echo "$TARGET" | sed 's/@.*//' | sed 's/[._]/ /g')
            DOMAIN=$(echo "$TARGET" | sed 's/.*@//')
            FIRST_NAME=$(echo "$NAME" | awk '{print $1}')
            
            cat > /tmp/prompt.txt << EOF
          Draft an outreach email to: $TARGET

          Recipient: $FIRST_NAME at $DOMAIN

          Write in Ankit's style:
          - Friendly, conversational (Hey [Name],)
          - Short paragraphs
          - Mention something specific about their company
          - Offer value (credits, call, Slack channel)
          - Casual sign-off (Talk soon!)
          - Include a PS with extra gesture

          Format response as:

          ## About $DOMAIN
          [2-3 sentences]

          ## Email Draft
          From: Ankit Pansari <ankit@trychroma.com>
          To: $TARGET
          Cc: Jeff Huber <jeff@trychroma.com>
          Subject: [subject]

          Hey $FIRST_NAME,

          [body]

          Talk soon!

          PS: [gesture]
          EOF
          
          elif [ "$MODE" == "research" ]; then
            cat > /tmp/prompt.txt << EOF
          Research $TARGET as a Chroma prospect.

          Provide:
          - Company Overview (what they do, size)
          - AI Relevance (AI products, use cases)
          - Chroma Fit Score (1-5)
          - Outreach Angle
          - Risks
          EOF
          
          elif [ "$MODE" == "linkedin" ]; then
            cat > /tmp/prompt.txt << EOF
          Draft LinkedIn post about: $TARGET

          Rules:
          - Under 1300 chars
          - Strong hook first line
          - Conversational, authentic
          - End with question

          Provide: Post, 3 Alt Hooks, Hashtags
          EOF
          
          elif [ "$MODE" == "competitor" ]; then
            cat > /tmp/prompt.txt << EOF
          Competitor question: $TARGET

          Give specific, actionable insights about competing with this.
          EOF
          
          else
            echo "$QUERY" > /tmp/prompt.txt
            echo "" >> /tmp/prompt.txt
            echo "Answer based on Chroma GTM context. Be helpful and specific." >> /tmp/prompt.txt
          fi
          
          echo "Prompt built for mode: $MODE"
      
      - name: Call Claude API
        id: api
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Check if API key exists
          if [ -z "$ANTHROPIC_API_KEY" ]; then
            echo "ERROR: ANTHROPIC_API_KEY is not set"
            echo "Error: API key not configured. Please add ANTHROPIC_API_KEY to repository secrets." > /tmp/response.txt
            exit 0
          fi
          
          # Prepare JSON-safe strings
          CONTEXT=$(cat /tmp/context_final.txt | jq -Rs .)
          PROMPT=$(cat /tmp/prompt.txt | jq -Rs .)
          
          SYSTEM="You are helping Ankit with GTM tasks for Chroma (AI context layer, 100M+ downloads). Be friendly and conversational. Never say vector database - say context layer."
          SYSTEM_JSON=$(echo "$SYSTEM" | jq -Rs .)
          
          echo "Calling Claude API..."
          
          # Make API call with error handling
          HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://api.anthropic.com/v1/messages \
            -H "Content-Type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "{
              \"model\": \"claude-sonnet-4-20250514\",
              \"max_tokens\": 2048,
              \"messages\": [{\"role\": \"user\", \"content\": $PROMPT}],
              \"system\": $SYSTEM_JSON
            }")
          
          # Extract response body and status code
          HTTP_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
          HTTP_STATUS=$(echo "$HTTP_RESPONSE" | tail -n1)
          
          echo "HTTP Status: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "API Error. Status: $HTTP_STATUS"
            echo "Response: $HTTP_BODY"
            ERROR_MSG=$(echo "$HTTP_BODY" | jq -r '.error.message // "Unknown API error"')
            echo "Error calling Claude API: $ERROR_MSG (HTTP $HTTP_STATUS)" > /tmp/response.txt
          else
            # Extract the response text
            ANSWER=$(echo "$HTTP_BODY" | jq -r '.content[0].text // "No response received"')
            echo "$ANSWER" > /tmp/response.txt
          fi
          
          echo "Response saved. First 200 chars:"
          head -c 200 /tmp/response.txt
      
      - name: Post response
        uses: actions/github-script@v7
        env:
          MODE: ${{ steps.parse.outputs.mode }}
        with:
          script: |
            const fs = require('fs');
            const response = fs.readFileSync('/tmp/response.txt', 'utf8');
            const mode = process.env.MODE;
            
            const emoji = {
              email: 'ğŸ“§', research: 'ğŸ”', linkedin: 'ğŸ“±',
              competitor: 'âš”ï¸', general: 'ğŸ¤–', followup: 'ğŸ’¬'
            }[mode] || 'ğŸ¤–';
            
            const label = {
              email: 'Email Draft', research: 'Company Research', 
              linkedin: 'LinkedIn Post', competitor: 'Competitor Intel',
              general: 'Response', followup: 'Updated'
            }[mode] || 'Response';
            
            const body = [
              `## ${emoji} ${label}`,
              '',
              response,
              '',
              '---',
              '<sub>ğŸ’¬ Reply with `@claude` for changes</sub>'
            ].join('\n');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
      
      - name: Handle errors
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '## âš ï¸ Error\n\nWorkflow failed. Check the [logs](' + context.serverUrl + '/' + context.repo.owner + '/' + context.repo.repo + '/actions) for details.'
            });
